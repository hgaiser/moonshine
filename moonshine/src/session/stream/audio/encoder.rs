use openssl::cipher::Cipher;
use reed_solomon_erasure::{galois_8, ReedSolomon};
use tokio::sync::mpsc;

use crate::{crypto::encrypt, session::{stream::RtpHeader, SessionKeys}};

#[derive(Debug)]
#[repr(C)]
struct AudioFecHeader {
	pub shard_index: u8,
	pub payload_type: u8,
	pub base_sequence_number: u16,
	pub base_timestamp: u32,
	pub ssrc: u32,
}

enum AudioEncoderCommand {
	UpdateKeys(SessionKeys),
}

pub struct AudioEncoder {
	command_tx: mpsc::Sender<AudioEncoderCommand>,
}

impl AudioEncoder {
	pub fn new(
		sample_rate: u32,
		channels: u8,
		audio_rx: mpsc::Receiver<Vec<i16>>,
		keys: SessionKeys,
		packet_tx: mpsc::Sender<Vec<u8>>
	) -> Result<Self, ()> {
		log::debug!("Creating audio encoder with sample rate {} and {} channels.", sample_rate, channels);
		let mut encoder = opus::Encoder::new(
			sample_rate,
			if channels > 1 { opus::Channels::Stereo } else { opus::Channels::Mono },
			opus::Application::LowDelay,
		)
			.map_err(|e| log::error!("Failed to create audio encoder: {e}"))?;

		// Moonlight expects a constant bitrate.
		encoder.set_vbr(false)
			.map_err(|e| log::error!("Failed to disable variable bitrate: {e}"))?;

		let (command_tx, command_rx) = mpsc::channel(10);
		let inner = AudioEncoderInner { };
		tokio::spawn(inner.run(command_rx, audio_rx, encoder, keys, packet_tx));

		Ok(Self { command_tx })
	}

	pub async fn update_keys(&self, keys: SessionKeys) -> Result<(), ()> {
		self.command_tx.send(AudioEncoderCommand::UpdateKeys(keys)).await
			.map_err(|e| log::error!("Failed to send UpdateKeys command: {e}"))
	}
}

struct AudioEncoderInner {
}

impl AudioEncoderInner {
	async fn run(
		self,
		mut command_rx: mpsc::Receiver<AudioEncoderCommand>,
		mut audio_rx: mpsc::Receiver<Vec<i16>>,
		mut encoder: opus::Encoder,
		mut keys: SessionKeys,
		packet_tx: mpsc::Sender<Vec<u8>>,
	) -> Result<(), ()> {
		let mut sequence_number = 0u16;
		let stream_start_time = std::time::Instant::now();

		const NR_DATA_SHARDS: usize = 4;
		const NR_PARITY_SHARDS: usize = 2;
		const NR_TOTAL_SHARDS: usize = NR_DATA_SHARDS + NR_PARITY_SHARDS;
		const MAX_SHARD_SIZE: usize = ((2048 + 15) / 16) * 16; // Where does this come from?
		let mut fec_encoder = ReedSolomon::<galois_8::Field>::new(NR_DATA_SHARDS, NR_PARITY_SHARDS)
			.map_err(|e| log::error!("Failed to create FEC encoder: {e}"))?;

		// For unknown reasons, the RS parity matrix computed by our RS implementation
		// doesn't match the one Nvidia uses for audio data. I'm not exactly sure why,
		// but we can simply replace it with the matrix generated by OpenFEC which
		// works correctly. This is possible because the data and FEC shard count is
		// constant and known in advance.
		// Source: https://github.com/moonlight-stream/moonlight-common-c/blob/5de4a5b85a28d8d639482a1a105c3a06eb67a2fd/src/RtpAudioQueue.c#L57
		// TODO: Find a way to fix this, it is very ugly..
		fec_encoder.set_parity_matrix(&[0x77, 0x40, 0x38, 0x0e, 0xc7, 0xa7, 0x0d, 0x6c]);
		let mut fec_encoder = reed_solomon_erasure::ShardByShard::new(&fec_encoder);

		let mut shards = vec![vec![0u8; MAX_SHARD_SIZE]; NR_TOTAL_SHARDS];

		// These values will be used for the parity shards, but they need to be copied from the first data shard.
		let mut base_sequence_number = 0u16;
		let mut base_timestamp = 0u32;

		loop {
			tokio::select! {
				command = command_rx.recv() => {
					let Some(command) = command else {
						log::debug!("Command channel closed.");
						break;
					};

					match command {
						AudioEncoderCommand::UpdateKeys(new_keys) => {
							log::debug!("Updating session keys.");
							keys = new_keys;
						}
					}
				},

				audio_fragment = audio_rx.recv() => {
					let Some(audio_fragment) = audio_fragment else {
						log::debug!("Audio fragment channel closed.");
						break;
					};

					let timestamp = ((std::time::Instant::now() - stream_start_time).as_micros() / (1000 / 90)) as u32;
					let encoded = match encoder.encode_vec(&audio_fragment, audio_fragment.len()) {
						Ok(encoded) => encoded,
						Err(e) => {
							log::warn!("Failed to encode audio: {e}");
							let _ = encoder.reset_state().map_err(|e| log::error!("Failed to reset Opus encoder state: {e}"));
							continue;
						}
					};

					// Encrypt the audio data.
					// TODO: Check if we should, some clients (ie. Steam Link) don't support this.
					let iv = keys.remote_input_key_id as u32 + sequence_number as u32;
					let mut iv = iv.to_be_bytes().to_vec();
					iv.extend([0u8; 12]);
					let payload = match encrypt(Cipher::aes_128_cbc(), &encoded, Some(&keys.remote_input_key), Some(&iv), true) {
						Ok(payload) => payload,
						Err(e) => {
							log::error!("Failed to encrypt audio: {e}");
							continue;
						},
					};

					let shard = &mut shards[sequence_number as usize % NR_DATA_SHARDS];

					{
						// Set the RTP header in the memory of the shard.
						let rtp_header = unsafe { &mut *(shard.as_mut_ptr() as *mut RtpHeader) };
						rtp_header.header = 0x80u8.to_be(); // What is this?
						rtp_header.packet_type = 97u8.to_be(); // RTP_PAYLOAD_TYPE_AUDIO
						rtp_header.sequence_number = sequence_number.to_be();
						rtp_header.timestamp = timestamp.to_be();
						rtp_header.ssrc = 0;

						// For FEC, copy the sequence number and timestamp of the first of the sequence of audio packets.
						if sequence_number as usize % NR_DATA_SHARDS == 0 {
							// Copy some values, but note that they are big-endian (as expected by Moonlight).
							base_sequence_number = rtp_header.sequence_number;
							base_timestamp = rtp_header.timestamp;
						}
					}

					sequence_number += 1;

					// Copy the payload to the shard.
					unsafe {
						std::ptr::copy_nonoverlapping(
							payload.as_ptr(),
							shard.as_mut_ptr().add(std::mem::size_of::<RtpHeader>()),
							payload.len()
						);
					}

					// Crop the shard to the length that we want to send it.
					let data_shard_size = std::mem::size_of::<RtpHeader>() + payload.len();
					let data_shard = shard[..data_shard_size].to_vec(); // TODO: Can we avoid this copy?

					if packet_tx.send(data_shard).await.is_err() {
						log::debug!("Failed to send packet over channel, channel is likely closed.");
						break;
					}

					{
						// Create a view of just the data itself for encoding.
						let mut shards: Vec<&mut [u8]> = shards.iter_mut().map(|s| &mut s[..data_shard_size]).collect();
						if let Err(e) = fec_encoder.encode(&mut shards) {
							log::warn!("Failed to encode data shard in FEC block: {e}");
						}
					}

					// If the last packet, compute and send parity shards.
					if sequence_number as usize % NR_DATA_SHARDS == 0 {
						if fec_encoder.reset().is_err() {
							log::warn!("Parity is not ready, but we were expecting it to be ready.");
							fec_encoder.reset_force();
							continue;
						}

						for (shard_index, shard) in shards[NR_DATA_SHARDS..].iter_mut().enumerate() {
							{
								let rtp_header = unsafe { &mut *(shard.as_mut_ptr() as *mut RtpHeader) };
								rtp_header.sequence_number = (sequence_number + shard_index as u16).to_be();
								rtp_header.packet_type = 127u8.to_be();
								rtp_header.timestamp = 0u32.to_be();
								rtp_header.ssrc = 0u32.to_be();
							}

							// Make room for the AudioFecHeader by moving the payload back.
							unsafe {
								std::ptr::copy(
									shard.as_mut_ptr().add(std::mem::size_of::<RtpHeader>()),
									shard.as_mut_ptr().add(std::mem::size_of::<RtpHeader>() + std::mem::size_of::<AudioFecHeader>()),
									payload.len()
								);
							}

							{
								let fec_header = unsafe { &mut *(shard.as_mut_ptr().add(std::mem::size_of::<RtpHeader>()) as *mut AudioFecHeader) };
								fec_header.shard_index = (shard_index as u8).to_be();
								fec_header.payload_type = 97u8.to_be();
								fec_header.base_sequence_number = base_sequence_number; // Already in big-endian
								fec_header.base_timestamp = base_timestamp; // Already in big-endian
								fec_header.ssrc = 0u32;
							}

							let parity_shard_size = std::mem::size_of::<RtpHeader>() + std::mem::size_of::<AudioFecHeader>() + payload.len();
							let parity_shard = shard[..parity_shard_size].to_vec(); // TODO: Can we avoid this copy?

							if packet_tx.send(parity_shard).await.is_err() {
								log::debug!("Failed to send packet over channel, channel is likely closed.");
								break;
							}
						}
					}
				}
			}
		}

		log::debug!("Audio capture channel closed.");
		Ok(())
	}
}
