use async_shutdown::ShutdownManager;
use openssl::cipher::Cipher;
use reed_solomon_erasure::{galois_8, ReedSolomon};
use tokio::sync::mpsc::{self, error::TryRecvError};

use crate::{crypto::encrypt, session::{manager::SessionShutdownReason, stream::RtpHeader, SessionKeys}};

const NR_DATA_SHARDS: usize = 4;
const NR_PARITY_SHARDS: usize = 2;
const NR_TOTAL_SHARDS: usize = NR_DATA_SHARDS + NR_PARITY_SHARDS;
const MAX_SHARD_SIZE: usize = 2048_usize.div_ceil(16) * 16; // Where does this come from?

#[derive(Debug)]
#[repr(C)]
struct AudioFecHeader {
	pub shard_index: u8,
	pub payload_type: u8,
	pub base_sequence_number: u16,
	pub base_timestamp: u32,
	pub ssrc: u32,
}

enum AudioEncoderCommand {
	UpdateKeys(SessionKeys),
}

pub struct AudioEncoder {
	command_tx: mpsc::Sender<AudioEncoderCommand>,
}

impl AudioEncoder {
	pub fn new(
		sample_rate: u32,
		channels: u8,
		audio_rx: mpsc::Receiver<Vec<f32>>,
		keys: SessionKeys,
		packet_tx: mpsc::Sender<Vec<u8>>,
		stop_session_manager: ShutdownManager<SessionShutdownReason>,
	) -> Result<Self, ()> {
		// TODO: Make this configurable.
		let audio_bitrate = 512000;

		tracing::debug!("Starting audio encoder.");
		tracing::debug!("Creating audio encoder with sample rate {} and {} channels.", sample_rate, channels);

		let mut encoder = opus::Encoder::new(
			sample_rate,
			if channels > 1 { opus::Channels::Stereo } else { opus::Channels::Mono },
			opus::Application::LowDelay,
		)
			.map_err(|e| tracing::error!("Failed to create audio encoder: {e}"))?;

		// Moonlight expects a constant bitrate.
		encoder.set_vbr(false)
			.map_err(|e| tracing::error!("Failed to disable variable bitrate: {e}"))?;
		encoder.set_bitrate(opus::Bitrate::Bits(audio_bitrate))
			.map_err(|e| tracing::error!("Failed to set audio bitrate: {e}"))?;

		let fec_encoder = ReedSolomon::<galois_8::Field>::new(NR_DATA_SHARDS, NR_PARITY_SHARDS)
			.map_err(|e| tracing::error!("Failed to create FEC encoder: {e}"))?;

		let (command_tx, command_rx) = mpsc::channel(10);
		let inner = AudioEncoderInner { };
		std::thread::Builder::new().name("audio-encode".to_string()).spawn(
			move || inner.run(
				command_rx,
				audio_rx,
				fec_encoder,
				encoder,
				keys,
				packet_tx,
				stop_session_manager,
			)
		)
			.map_err(|e| tracing::error!("Failed to start audio encode thread: {e}"))?;

		Ok(Self { command_tx })
	}

	pub async fn update_keys(&self, keys: SessionKeys) -> Result<(), ()> {
		self.command_tx.send(AudioEncoderCommand::UpdateKeys(keys)).await
			.map_err(|e| tracing::error!("Failed to send UpdateKeys command: {e}"))
	}
}

struct AudioEncoderInner {
}

impl AudioEncoderInner {
	#[allow(clippy::too_many_arguments)] // TODO: Problem for later..
	fn run(
		self,
		mut command_rx: mpsc::Receiver<AudioEncoderCommand>,
		mut audio_rx: mpsc::Receiver<Vec<f32>>,
		mut fec_encoder: ReedSolomon<galois_8::Field>,
		mut encoder: opus::Encoder,
		mut keys: SessionKeys,
		packet_tx: mpsc::Sender<Vec<u8>>,
		stop_session_manager: ShutdownManager<SessionShutdownReason>,
	) {
		// Trigger session shutdown when the audio encoder stops.
		let _session_stop_token = stop_session_manager.trigger_shutdown_token(SessionShutdownReason::AudioEncoderStopped);
		let _delay_stop = stop_session_manager.delay_shutdown_token();

		let mut sequence_number = 0u16;
		let stream_start_time = std::time::Instant::now();

		// For unknown reasons, the RS parity matrix computed by our RS implementation
		// doesn't match the one Nvidia uses for audio data. I'm not exactly sure why,
		// but we can simply replace it with the matrix generated by OpenFEC which
		// works correctly. This is possible because the data and FEC shard count is
		// constant and known in advance.
		// Source: https://github.com/moonlight-stream/moonlight-common-c/blob/5de4a5b85a28d8d639482a1a105c3a06eb67a2fd/src/RtpAudioQueue.c#L57
		// TODO: Find a way to fix this, it is very ugly..
		fec_encoder.set_parity_matrix(&[0x77, 0x40, 0x38, 0x0e, 0xc7, 0xa7, 0x0d, 0x6c]);
		let mut fec_encoder = reed_solomon_erasure::ShardByShard::new(&fec_encoder);

		let mut shards = vec![vec![0u8; MAX_SHARD_SIZE]; NR_TOTAL_SHARDS];

		// These values will be used for the parity shards, but they need to be copied from the first data shard.
		let mut base_sequence_number = 0u16;
		let mut base_timestamp = 0u32;

		// A buffer for an audio sample after it has been encoded.
		// TODO: Decide the correct size for this buffer.
		let mut encoded_audio = vec![0u8; 1400];

		while !stop_session_manager.is_shutdown_triggered() {
			// Check if there's a command.
			match command_rx.try_recv() {
				Ok(command) => {
					match command {
						AudioEncoderCommand::UpdateKeys(new_keys) => {
							tracing::debug!("Updating session keys.");
							keys = new_keys;
						}
					}
				},
				Err(TryRecvError::Disconnected) => {
					// If for whatever reason AudioStream is dropped, this channel is dropped unexpectedly.
					tracing::debug!("Audio encoder command channel closed.");
					break;
				},
				Err(TryRecvError::Empty) => { },
			};

			let audio_fragment = audio_rx.blocking_recv();
			let Some(audio_fragment) = audio_fragment else {
				tracing::debug!("Audio fragment channel closed.");
				break;
			};

			// TODO: Figure out the 1000 / 90 value.
			let timestamp = ((std::time::Instant::now() - stream_start_time).as_micros() / (1000 / 90)) as u32;
			let encoded_size = match encoder.encode_float(&audio_fragment, &mut encoded_audio) {
				Ok(encoded_size) => encoded_size,
				Err(e) => {
					tracing::warn!("Failed to encode audio: {e}");
					let _ = encoder.reset_state().map_err(|e| tracing::error!("Failed to reset Opus encoder state: {e}"));
					continue;
				}
			};


			// Encrypt the audio data.
			// TODO: Check if we should, some clients (ie. Steam Link) don't support this.
			let iv = keys.remote_input_key_id as u32 + sequence_number as u32;
			let mut iv = iv.to_be_bytes().to_vec();
			iv.extend([0u8; 12]);
			let payload = match encrypt(Cipher::aes_128_cbc(), &encoded_audio[..encoded_size], Some(&keys.remote_input_key), Some(&iv), None, true) {
				Ok(payload) => payload,
				Err(e) => {
					tracing::error!("Failed to encrypt audio: {e}");
					continue;
				},
			};

			let shard = &mut shards[sequence_number as usize % NR_DATA_SHARDS];

			{
				// Set the RTP header in the memory of the shard.
				let rtp_header = unsafe { &mut *(shard.as_mut_ptr() as *mut RtpHeader) };
				rtp_header.header = 0x80u8.to_be(); // What is this?
				rtp_header.packet_type = 97u8.to_be(); // RTP_PAYLOAD_TYPE_AUDIO
				rtp_header.sequence_number = sequence_number.to_be();
				rtp_header.timestamp = timestamp.to_be();
				rtp_header.ssrc = 0;

				// For FEC, copy the sequence number and timestamp of the first of the sequence of audio packets.
				if (sequence_number as usize).is_multiple_of(NR_DATA_SHARDS) {
					// Copy some values, but note that they are big-endian (as expected by Moonlight).
					base_sequence_number = rtp_header.sequence_number;
					base_timestamp = rtp_header.timestamp;
				}
			}

			sequence_number = sequence_number.wrapping_add(1);

			// Copy the payload to the shard.
			unsafe {
				std::ptr::copy_nonoverlapping(
					payload.as_ptr(),
					shard.as_mut_ptr().add(std::mem::size_of::<RtpHeader>()),
					payload.len()
				);
			}

			// Crop the shard to the length that we want to send it.
			let data_shard_size = std::mem::size_of::<RtpHeader>() + payload.len();
			let data_shard = shard[..data_shard_size].to_vec(); // TODO: Can we avoid this copy?

			if packet_tx.blocking_send(data_shard).is_err() {
				tracing::debug!("Failed to send packet over channel, channel is likely closed.");
				break;
			}

			{
				// Create a view of just the data itself for encoding.
				let mut shards: Vec<&mut [u8]> = shards.iter_mut().map(|s| &mut s[..data_shard_size]).collect();
				if let Err(e) = fec_encoder.encode(&mut shards) {
					tracing::warn!("Failed to encode data shard in FEC block: {e}");
				}
			}

			// If the last packet, compute and send parity shards.
			if (sequence_number as usize).is_multiple_of(NR_DATA_SHARDS) {
				if fec_encoder.reset().is_err() {
					tracing::warn!("Parity is not ready, but we were expecting it to be ready.");
					fec_encoder.reset_force();
					continue;
				}

				for (shard_index, shard) in shards[NR_DATA_SHARDS..].iter_mut().enumerate() {
					{
						let rtp_header = unsafe { &mut *(shard.as_mut_ptr() as *mut RtpHeader) };
						rtp_header.sequence_number = (sequence_number + shard_index as u16).to_be();
						rtp_header.packet_type = 127u8.to_be();
						rtp_header.timestamp = 0u32.to_be();
						rtp_header.ssrc = 0u32.to_be();
					}

					// Make room for the AudioFecHeader by moving the payload back.
					unsafe {
						std::ptr::copy(
							shard.as_mut_ptr().add(std::mem::size_of::<RtpHeader>()),
							shard.as_mut_ptr().add(std::mem::size_of::<RtpHeader>() + std::mem::size_of::<AudioFecHeader>()),
							payload.len()
						);
					}

					{
						let fec_header = unsafe { &mut *(shard.as_mut_ptr().add(std::mem::size_of::<RtpHeader>()) as *mut AudioFecHeader) };
						fec_header.shard_index = (shard_index as u8).to_be();
						fec_header.payload_type = 97u8.to_be();
						fec_header.base_sequence_number = base_sequence_number; // Already in big-endian
						fec_header.base_timestamp = base_timestamp; // Already in big-endian
						fec_header.ssrc = 0u32;
					}

					let parity_shard_size = std::mem::size_of::<RtpHeader>() + std::mem::size_of::<AudioFecHeader>() + payload.len();
					let parity_shard = shard[..parity_shard_size].to_vec(); // TODO: Can we avoid this copy?

					if packet_tx.blocking_send(parity_shard).is_err() {
						tracing::debug!("Failed to send packet over channel, channel is likely closed.");
						break;
					}
				}
			}
		}

		tracing::debug!("Audio encoder stopped.");
	}
}
